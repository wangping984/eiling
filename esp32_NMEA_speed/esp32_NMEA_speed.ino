#include <Adafruit_GPS.h>

#define GPS_TX 12
#define GPS_RX 18
#define GPSSerial Serial1
// Connect to the GPS on the hardware port
Adafruit_GPS GPS(&GPSSerial);
#define GPSECHO false
uint32_t timer = millis();
uint32_t timer1 = millis();

char terminateChar = '\n';       // 建立终止字符
const int bufferLength = 100;    // 定义缓存大小为10个字节
char serialBuffer[bufferLength]; // 建立字符数组用于缓存

void setup()
{
  // Open serial communications and wait for port to open:
  Serial.begin(115200);
  while (!Serial)
  {
    ; // wait for serial port to connect. Needed for Native USB only
  }

  Serial.println("Goodnight moon!");

  GPSSerial.begin(9600, SERIAL_8N1, GPS_TX, GPS_RX);
  //   set GPS 115200 baud rate
  byte message[] = {0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x31, 0x2C, 0x35, 0x2A, 0x31, 0x39, 0x0D, 0x0A};
  GPSSerial.write(message, sizeof(message));
  GPSSerial.flush();
  GPSSerial.begin(115200, SERIAL_8N1, GPS_TX, GPS_RX);
  // set GPS 5Hz update rate
  byte message0[] = {0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x32, 0x2C, 0x32, 0x30, 0x30, 0x2A, 0x31, 0x44, 0x0D, 0x0A};
  GPSSerial.write(message0, sizeof(message0));

  //   关闭GLL
  // 0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A
  // 关闭GSA
  // 0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x2C, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A
  // 关闭GSV
  // 0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x2C, 0x2C, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A
  // 关闭VGT
  // 0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A
  // 关闭ZDA
  // 0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A
  // 关闭TXT
  // 0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A
  byte message1[] = {0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A};
  GPSSerial.write(message1, sizeof(message1));
  byte message2[] = {0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x2C, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A};
  GPSSerial.write(message2, sizeof(message2));
  byte message3[] = {0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x2C, 0x2C, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A};
  GPSSerial.write(message3, sizeof(message3));
  byte message4[] = {0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A};
  GPSSerial.write(message4, sizeof(message4));
  byte message5[] = {0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A};
  GPSSerial.write(message5, sizeof(message5));
  byte message6[] = {0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A};
  GPSSerial.write(message6, sizeof(message6));
  //   关闭GGA
  // 0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A
  //  byte message7[] = {0x24, 0x50, 0x43, 0x41, 0x53, 0x30, 0x33, 0x2C, 0x30, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2A, 0x33, 0x32, 0x0D, 0x0A};
  //  GPSSerial.write(message7, sizeof(message7));

  //  Serial1.setRxBufferSize(1024);
}

void loop() // run over and over
{
  if (millis() - timer1 >= 0)
  {
    // timer1 = millis(); // reset the timer
    
    if (GPSSerial.available())
    {
      Serial.print(millis(), DEC);
      Serial.print("   start availabe: ");
      Serial.print(GPSSerial.available());
      Serial.print("    ");
      GPSSerial.readBytesUntil(terminateChar, serialBuffer, bufferLength); // 将接收到的信息使用read读取
      for (int i = 0; i < bufferLength; i++)
      {                                // 然后通过串口监视器输出readBytesUntil
        Serial.print(serialBuffer[i]); // 函数所读取的信息
      }
      Serial.print("\n");
      GPS.parse(serialBuffer);
    }
    if (GPSSerial.available())
    {
      Serial.print(millis(), DEC);
      Serial.print("         availabe: ");
      Serial.print(GPSSerial.available());
      Serial.print("    ");
      GPSSerial.readBytesUntil(terminateChar, serialBuffer, bufferLength); // 将接收到的信息使用read读取
      for (int i = 0; i < bufferLength; i++)
      {                                // 然后通过串口监视器输出readBytesUntil
        Serial.print(serialBuffer[i]); // 函数所读取的信息
      }
      Serial.print("\n");
      GPS.parse(serialBuffer);
    }

    

    // read data from the GPS in the 'main loop'
    //    char c = GPS.read();
    // if you want to debug, this is a good time to do it!
    //    if (GPSECHO)
    //      if (c)
    //        Serial.print(c);
    // if a sentence is received, we can check the checksum, parse it...
    if (GPS.newNMEAreceived())
    {
      // a tricky thing here is if we print the NMEA sentence, or data
      // we end up not listening and catching other sentences!
      // so be very wary if using OUTPUT_ALLDATA and trying to print out data
      Serial.print(GPS.lastNMEA());   // this also sets the newNMEAreceived() flag to false
      if (!GPS.parse(GPS.lastNMEA())) // this also sets the newNMEAreceived() flag to false
        return;                       // we can fail to parse a sentence in which case we should just wait for another
      Serial.print("   Time to parse: ");
      Serial.print(millis(), DEC);
      Serial.print("         millis: ");
      Serial.print(millis(), DEC);
      Serial.print("  \n");
    }
  }

  // approximately every 2 seconds or so, print out the current stats
  if (millis() - timer > 2000)
  {
    timer = millis(); // reset the timer
    Serial.print("\nTime: ");
    if (GPS.hour < 10)
    {
      Serial.print('0');
    }
    Serial.print(GPS.hour, DEC);
    Serial.print(':');
    if (GPS.minute < 10)
    {
      Serial.print('0');
    }
    Serial.print(GPS.minute, DEC);
    Serial.print(':');
    if (GPS.seconds < 10)
    {
      Serial.print('0');
    }
    Serial.print(GPS.seconds, DEC);
    Serial.print('.');
    if (GPS.milliseconds < 10)
    {
      Serial.print("00");
    }
    else if (GPS.milliseconds > 9 && GPS.milliseconds < 100)
    {
      Serial.print("0");
    }
    Serial.println(GPS.milliseconds);
    Serial.print("Date: ");
    Serial.print(GPS.day, DEC);
    Serial.print('/');
    Serial.print(GPS.month, DEC);
    Serial.print("/20");
    Serial.println(GPS.year, DEC);
    Serial.print("Fix: ");
    Serial.print((int)GPS.fix);
    Serial.print(" quality: ");
    Serial.println((int)GPS.fixquality);
    if (GPS.fix)
    {
      Serial.print("Location: ");
      Serial.print(GPS.latitude, 4);
      Serial.print(GPS.lat);
      Serial.print(", ");
      Serial.print(GPS.longitude, 4);
      Serial.println(GPS.lon);
      Serial.print("Speed (knots): ");
      Serial.println(GPS.speed);
      Serial.print("Angle: ");
      Serial.println(GPS.angle);
      Serial.print("Altitude: ");
      Serial.println(GPS.altitude);
      Serial.print("Satellites: ");
      Serial.println((int)GPS.satellites);
    }
  }
}
